# .NET Exceptions - System.NullReferenceException

Next in our journey through our extensive __.NET Exception Handling__ series, today we'll be taking a closer look at the `System.NullReferenceException`.  The `System.NullReferenceException` is commonly thrown when attempting to access a member that has a `null` value type.

In this article, we'll take a closer look at where `System.NullReferenceException` resides within the .NET exception hierarchy, detail when `System.NullReferenceExceptions` most commonly appear, and see how to handle it should you encounter one yourself.  So, let's get going!

## The Technical Rundown

- All .NET exceptions are derived classes of the [`System.Exception`](https://airbrake.io/blog/dotnet-exception-handling/exception-class-hierarchy) base class, or derived from another inherited class therein.
- The [`System.SystemException`](https://msdn.microsoft.com/en-us/library/system.systemexception(v=vs.110).aspx) class is inherited from the [`System.Exception`](https://airbrake.io/blog/dotnet-exception-handling/exception-class-hierarchy) class.
- `System.NullReferenceException` is inherited from the [`System.SystemException`](https://msdn.microsoft.com/en-us/library/system.systemexception(v=vs.110).aspx) class.

## When Should You Use It?

As discussed in the introduction, `System.NullReferenceExceptions` occur when attempting to `deference` a null object reference.  Since most development via .NET is pre-compiled prior to execution, oftentimes a potential `System.NullReferenceException` is caught by the compiler and displayed in your IDE or terminal as such, without ever executing the application code.  However, it depends not only on the compiler you are using, but also the actual code itself (and therefore, what it is you're trying to dereference).

To see this in action, here we've got a simple example using our `CreateList()` method.  Inside the `CreateList()` method we're just creating a `List` of `strings` called `names`, then adding a few names to our list:

```cs
using System;
using System.Collections.Generic;

namespace ConsoleApplication
{
    public class NullReferenceExceptionExample
    {
        public static void Main(string[] args)
        {
            CreateList();            
        }

        private static void CreateList()
        {            
            try   
            {
                int value = 0;
                List<String> names;
                if (value > 0)
                {
                    names = new List<String>();
                }

                names.Add("Alice Bob Chris");
            }
            catch(NullReferenceException exception)
            {
                LogException(exception);
            }
        }

        private static void LogException(Exception exception, bool expected = true)
        {
            Console.WriteLine($"[{(expected ? "EXPECTED" : "UNEXPECTED")}] {exception.ToString()}: {exception.Message}");
        }
    }
}
```

As it happens, the compiler takes offense to this, and spits out this ugly error:

```
Compiling System.NullReferenceException for .NETCoreApp,Version=v1.1
C:\Program Files\dotnet\dotnet.exe compile-csc @G:\dev\work\Airbrake.io\Exceptions\.NET\System.NullReferenceException\obj\Debug\netcoreapp1.1\dotnet-compile.rsp returned Exit Code 1
G:\dev\work\Airbrake.io\Exceptions\.NET\System.NullReferenceException\System.NullReferenceException.cs(42,17): error CS0165: Use of unassigned local variable 'names'

Compilation failed.
    0 Warning(s)
    1 Error(s)

Time elapsed 00:00:00.8662475
``` 

The critical bit is `error CS0165: Use of unassigned local variable 'names'`.  The [`CS0165`](https://msdn.microsoft.com/en-us/library/4y7h161d.aspx) compiler error is when the compiler recognizes that a variable is uninitialized, which is exactly the problem we've created in our code.  Specifically, this snippet here:

```cs
if (value > 0)
{
    names = new List<String>();
}
``` 

Since `value` is not guaranteed to exceed zero (and doesn't, in our case), `names` is never initialized as a `new List<String>()`, so the compiler catches it and throws that error.  While this isn't technically a `System.NullReferenceException`, since it wasn't generated by executing code, it falls into the same ballpark.  The obvious fix here is to initialize `names` when we first create it:

```cs
List<String> names = new List<String>();
```

Now, in some cases, we might see a `System.NullReferenceException` that is thrown during actual code execution.  For example, here we're calling our `CreateArray()` method and performing a simple loop to generate some values for our `int[]` array called `values`:

```cs
using System;
using System.Collections.Generic;

namespace ConsoleApplication
{
    public class NullReferenceExceptionExample
    {
        public static void Main(string[] args)
        {
            CreateArray();
        }

        private static void CreateArray()
        {            
            try   
            {
                int[] values = null;
                for (int count = 0; count <= 9; count++)
                    values[count] = count;

                foreach (var value in values)
                {
                    Console.WriteLine(value);
                }
            }
            catch(NullReferenceException exception)
            {
                LogException(exception);
            }
        }

        private static void LogException(Exception exception, bool expected = true)
        {
            Console.WriteLine($"[{(expected ? "EXPECTED" : "UNEXPECTED")}] {exception.ToString()}: {exception.Message}");
        }
    }
}
```

As you've probably suspected, .NET is none too pleased with this, and throws a `System.NullReferenceException`:

```
[EXPECTED] System.NullReferenceException: Object reference not set to an instance of an object.
   at ConsoleApplication.NullReferenceExceptionExample.CreateArray() in g:\dev\work\Airbrake.io\Exceptions\.NET\System.NullReferenceException\System.NullReferenceException.cs:line 20: Object reference not set to an instance of an object.
```

The `System.NullReferenceException` message is telling us that `line 20` is bad, which is this: `values[count] = count;`  The problem is that while we _did_ indicate that `values` is an array of integers, we never specified the dimensions of the array, so we produce a `System.NullReferenceException`.

Similar to before, the solution here is to specify the size of our array when we first initialize it:

```cs
int[] values = new int[10];
```

To get the most out of your own applications and to fully manage any and all .NET Exceptions, check out the <a class="js-cta-utm" href="https://airbrake.io/languages/net_bug_tracker?utm_source=blog&amp;utm_medium=end-post&amp;utm_campaign=airbrake-net">Airbrake .NET Bug Handler</a>, offering real-time alerts and instantaneous insight into what went wrong with your .NET code, along with built-in support for a variety of popular development integrations including: JIRA, GitHub, Bitbucket, and much more.

---

__META DESCRIPTION__

A basic introduction to the System.NullReferenceException in .NET, how to handle NullReferenceExceptions, and where they sit within the .NET exception hierarchy.

---

__SOURCES__

- https://msdn.microsoft.com/en-us/library/system.exception(v=vs.110).aspx
